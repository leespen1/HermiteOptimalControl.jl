var documenterSearchIndex = {"docs":
[{"location":"#HermiteOptimalControl.jl-Documentation","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"","category":"page"},{"location":"#Workflow","page":"HermiteOptimalControl.jl Documentation","title":"Workflow","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"Right now the user can set up Schrodinger problems, and compute the gradients of them with the control vector and target gate of their choosing. In a complete package, there would also be an optimization procedure which uses this gradient calculation.","category":"page"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"The basic workflow is:","category":"page"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"Set up a SchrodingerProblem, either yourself using the constructor SchrodingerProb, or by using one of the example problems provided. Schrodinger Problem Examples\nChoose a control vector and target.\nCompute a gradient using one of the methods provided. Gradient Evaluation","category":"page"},{"location":"#Functions","page":"HermiteOptimalControl.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"#Schrodinger-Problem-Definition","page":"HermiteOptimalControl.jl Documentation","title":"Schrodinger Problem Definition","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"SchrodingerProb","category":"page"},{"location":"#Schrodinger-Problem-Examples","page":"HermiteOptimalControl.jl Documentation","title":"Schrodinger Problem Examples","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"rabi_osc\ngargamel_prob\nbspline_prob","category":"page"},{"location":"#Forward-Evolution","page":"HermiteOptimalControl.jl Documentation","title":"Forward Evolution","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"Functions for evolving the state vector in a problem forward in time according to Schrodinger's equation, with or without forcing.","category":"page"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"eval_forward\neval_forward_forced","category":"page"},{"location":"#HermiteOptimalControl.eval_forward","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.eval_forward","text":"\n\n\n\n","category":"function"},{"location":"#Gradient-Evaluation","page":"HermiteOptimalControl.jl Documentation","title":"Gradient Evaluation","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"discrete_adjoint\neval_grad_forced\neval_grad_finite_difference\ninfidelity","category":"page"},{"location":"#HermiteOptimalControl.discrete_adjoint","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.discrete_adjoint","text":"Evaluates gradient of the provided Schrodinger problem with the given target gate and control parameter(s) pcof using the discrete adjoint method. \n\nReturns: gradient\n\n\n\n\n\n","category":"function"},{"location":"#HermiteOptimalControl.eval_grad_forced","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.eval_grad_forced","text":"Evaluates gradient of the provided Schrodinger problem with the given target gate and control parameter(s) pcof using the \"forward differentiation\" method, which evolves a differentiated Schrodinger equation, using the state vector in the evolution of the original Schrodinger equation as a forcing term.\n\nReturns: gradient\n\n\n\n\n\n","category":"function"},{"location":"#HermiteOptimalControl.eval_grad_finite_difference","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.eval_grad_finite_difference","text":"Vector control version.\n\nEvaluates gradient of the provided Schrodinger problem with the given target gate and control parameter(s) pcof using a finite difference method, where a step size of dpcof is used when perturbing the components of the control vector pcof.\n\nReturns: gradient\n\n\n\n\n\n","category":"function"},{"location":"#HermiteOptimalControl.infidelity","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.infidelity","text":"Calculates the infidelity for the given state vector 'ψ' and target state 'target.'\n\nReturns: Infidelity\n\n\n\n\n\nCalculates the infidelity for the given matrix of state vectors 'Q' and matrix of target states 'target.'\n\nReturns: Infidelity\n\n\n\n\n\n","category":"function"},{"location":"#Bsplines","page":"HermiteOptimalControl.jl Documentation","title":"Bsplines","text":"","category":"section"},{"location":"","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.jl Documentation","text":"bcparams\nbcarrier2\nbcarrier2_dt\ngradbcarrier2!\ngradbcarrier2_dt!","category":"page"},{"location":"#HermiteOptimalControl.bcparams","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.bcparams","text":"bcpar = bcparams(T, D1, Ncoupled, Nunc, omega, pcof)\n\nGeneral constructor of struct bcparams for setting up B-splines with carrier waves.\n\nbcpar = bcparams(T, D1, omega, pcof)\n\nSimplified constructor for the case when there are no uncoupled controls and Ncoupled = size(omega,1).\n\nArguments\n\nT:: Float64: Duration of spline function\nD1:: Int64: Number of basis functions in each segment\nNcoupled::Int64: Number of coupled controls in the simulation\nNunc::Int64: Number of uncoupled controls in the simulation\nomega::Array{Float64,2}: Carrier wave frequencies\npcof:: Array{Float64, 1}: Coefficient vector. Must have D1*Nseg elements\n\nFirst dimensions of the omega array:\n\nWithout uncoupled controls, Nunc=0 and size(omega,1) = Ncoupled.\nWith uncoupled controls, Nunc > 0 and size(omega,1) = Ncoupled + Nunc.\n\nSecond dimension of the omega array:\n\nsize(omega, 2) = Nfreq\n\nOrdering of the pcof array:\n\nFirst consider the case without uncoupled control functions, Nunc = 0:  Then the pcof array then has 2*Ncoupled*Nfreq*D1 elements.  Each ctrl ∈ [1,Ncoupled] and freq ∈ [1,Nfreq] corresponds to D1 elements in  the pcof vector. For the case Ncoupled = 2 and Nfreq = 2, the elements are ordered according to\n\nctrl freq α_1 α_2\n1 1 1:D1 D1+1:2 D1\n1 2 2 D1+1: 3 D1 3 D1+1:4 D1\n2 1 4 D1+1: 5 D1 5 D1+1:6 D1\n2 2 6 D1+1: 7 D1 7 D1+1: 8D1\n\nIf there are uncoupled controls, Nunc > 0, the pcof array should have (2*Ncoupled + Nunc)*Nfreq*D1 elements.  The last Nunc*Nfreq*D1 elements correspond to the uncoupled control functions and are ordered in a corresponding way.\n\nExternal links\n\nSpline Wavelet on Wikipedia.\n\n\n\n\n\n","category":"type"},{"location":"#HermiteOptimalControl.bcarrier2","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.bcarrier2","text":"f = bcarrier2(t, params, func)\n\nEvaluate a B-spline function with carrier waves. See also the bcparams constructor.\n\nArguments\n\nt::Float64: Evaluate spline at parameter t ∈ [0, param.T]\nparam::params: Parameters for the spline\nfunc::Int64: Spline function index ∈ [0, param.Nseg-1]\n\n\n\n\n\nf = bcarrier2(t, params, func)\n\nEvaluate a B-spline function with carrier waves. See also the bcparams constructor.\n\nArguments\n\nt::Float64: Evaluate spline at parameter t ∈ [0, param.T]\nparam::params: Parameters for the spline\nfunc::Int64: Spline function index ∈ [0, param.Nseg-1]\n\n\n\n\n\n","category":"function"},{"location":"#HermiteOptimalControl.bcarrier2_dt","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.bcarrier2_dt","text":"f = bcarrier2_dt(t, params, func)\n\nEvaluate a B-spline function with carrier waves. See also the bcparams constructor.\n\nArguments\n\nt::Float64: Evaluate spline at parameter t ∈ [0, param.T]\nparam::params: Parameters for the spline\nfunc::Int64: Spline function index ∈ [0, param.Nseg-1]\n\nSPENCER: To get cross derivative (d2/dtda, just remove the pcofs in the below, since the controls are linear in them)\n\n\n\n\n\nf = bcarrier2_dt(t, params, func)\n\nEvaluate a B-spline function with carrier waves. See also the bcparams constructor.\n\nArguments\n\nt::Float64: Evaluate spline at parameter t ∈ [0, param.T]\nparam::params: Parameters for the spline\nfunc::Int64: Spline function index ∈ [0, param.Nseg-1]\n\nSPENCER: To get cross derivative (d2/dtda, just remove the pcofs in the below, since the controls are linear in them)\n\n\n\n\n\n","category":"function"},{"location":"#HermiteOptimalControl.gradbcarrier2!","page":"HermiteOptimalControl.jl Documentation","title":"HermiteOptimalControl.gradbcarrier2!","text":"gradbcarrier2!(t, bcpar, func, g) -> g\n\nEvaluate the gradient of a control function with respect to all coefficient.\n\nNOTE: the index of the control functions is 0-based. For a set of  coupled controls, mod(func,2)=0 corresponds to ∇ pj(t) and mod(func,2) = 1  corresponds to ∇ qj(t), where j = div(func,2).\n\nArguments\n\nt::Float64: Evaluate spline at parameter t ∈ [0, param.T]\nbcpar::bcparams: Parameters for the spline\nfunc::Int64: Control function index ∈ [0, param.Nseg-1]\ng::Array{Float64,1}: Preallocated array to store calculated gradient\n\n\n\n\n\n","category":"function"}]
}
